\markdownRendererDocumentBegin
\markdownRendererHeadingTwo{Importeren}\markdownRendererInterblockSeparator
{}Stop het CA.py bestand in dezelfde map als het project, en importeer het als volgt:\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/e0e8f885a1ee4a42c1c6a1d7999ad6ce.verbatim}{python}\markdownRendererInterblockSeparator
{}Zorg er ook voor dat numpy geïnstalleerd is, want dat is wat gebruikt wordt voor het grid van de CA. Voor het gebruik maken van de ingebouwde visualisatie zal ook pygame geïnstalleerd moeten zijn.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Aanmaken van CA's}\markdownRendererInterblockSeparator
{}Verschillende cellulaire automaten kunnen gemaakt worden met behulp van de basisklasse \markdownRendererCodeSpan{CellularAutomata}. Een CA kan als volgt gemaakt worden:\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{myCA = CA.CellularAutomata(shape, rules)}\markdownRendererInterblockSeparator
{}waar shape de vorm van de CA is, wat weergegeven word als een lijst met het aantal cellen in elke dimensie, en rules de functie is die, gegeven een cell, de index van deze cell en de rest van het rooster, de geüpdate staat van deze cell geeft.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingThree{Voorbeeld 1}\markdownRendererInterblockSeparator
{}We maken hier een 3-dimensionale CA met in elke dimensie 10 cellen, die als regel heeft dat als een cell de waarde 1 heeft, hij 0 wordt en andersom.\markdownRendererInterblockSeparator
{}We definiëren eerst de functie voor onze regel, en vullen die in wanneer we de CA maken.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/f9624daaf07c5e283025ef4511cfea28.verbatim}{python}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingThree{1- en 2-dimensionale CA's}\markdownRendererInterblockSeparator
{}Ook kunnen we eenvoudig 1- en 2-dimensionale CA's maken met de \markdownRendererCodeSpan{Cellular1D} en \markdownRendererCodeSpan{Cellular2D} klassen. Deze bevatten al ingebouwde functies voor visualisatie, wat handig kan zijn.\markdownRendererInterblockSeparator
{}Een 1-dimensionale CA met 10 cellen kan als volgt worden aangemaakt:\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/898839900b5f7a9bb7a0a94a354bcc81.verbatim}{python}\markdownRendererInterblockSeparator
{}Merk op dat hier alleen een getal gegeven wordt voor de grootte, en geen lijst.\markdownRendererInterblockSeparator
{}Een 2-dimensionale CA met 10 cellen in de breedte en 5 in de hoogte kan als volgt worden gemaakt:\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/7fabc120c2d510822d7591457c016668.verbatim}{python}\markdownRendererInterblockSeparator
{}Ook hier wordt de breedte en hoogte los gegeven, en niet in een lijst.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Het invullen van cellen}\markdownRendererInterblockSeparator
{}Wanneer een CA wordt aangemaakt, begint hij met 0 in elke cell. Er zijn verschillende manieren om waardes aan cellen toe te kennen.\markdownRendererInterblockSeparator
{}De meest algemene, die voor elke CA werkt, is \markdownRendererCodeSpan{setcells}. Deze functie neemt een lijst met index-tuples en een bepaalde waarde, en kent voor elke index-tuple de bijbehorende cell de gegeven waarde toe.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/587856b4f54878115758b4bb364c9f55.verbatim}{python}\markdownRendererInterblockSeparator
{}Ook bestaat er een functie die alle waarden terugzet naar 0, \markdownRendererCodeSpan{setzeros}. Deze werkt ook voor elke CA.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/ef22feba104e01c5b73277d5baee128a.verbatim}{python}\markdownRendererInterblockSeparator
{}Daarnaast bestaat er ook de functie \markdownRendererCodeSpan{random}, die ook voor elke CA werkt, en die alle cellen random 0 of 1 maakt.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/9d8e71016742a40a5181d490c070b0ba.verbatim}{python}\markdownRendererInterblockSeparator
{}Verder is er ook een functie speciaal voor \markdownRendererCodeSpan{Cellular1D}, namelijk \markdownRendererCodeSpan{start\markdownRendererUnderscore{}middle}, die de cell in het midden naar 1 verandert.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/2c0cc4847d16a57922615e3ca1e1fd88.verbatim}{python}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Updaten van CA}\markdownRendererInterblockSeparator
{}Het updaten van CA's kan eenvoudig gedaan worden met de \markdownRendererCodeSpan{update} functie. Deze functie roept voor iedere cell de rules-functie op, en geeft de cell de output als waarde.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/fc363afdc9984b749d9b77ff7d48dadf.verbatim}{python}\markdownRendererInterblockSeparator
{}Ook kan de CA automatisch een gegeven aantal keer geupdate worden door middel van de \markdownRendererCodeSpan{run} functie. Deze neemt een getal voor het aantal keer dat de CA geupdate moet worden, en update hem dan zoveel keer.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/748294b85e93e2fef00b82f6ac89fbf8.verbatim}{python}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Grafische weergave}\markdownRendererInterblockSeparator
{}Voor de 1- en 2-dimensionale CA klassen bestaan er ingebouwde functies voor het visualiseren.\markdownRendererInterblockSeparator
{}Allereerst bestaat voor beide de \markdownRendererCodeSpan{draw} functie. Deze neemt als argumenten een screen (een pygame Surface), een cellsize voor de grootte van de cellen (in pixels), en een surflist, een lijst van pygame Surfaces.\markdownRendererInterblockSeparator
{}Het \markdownRendererCodeSpan{screen} is hetgeen waar alles op getekend word, en \markdownRendererCodeSpan{surflist} is een lijst met surfaces met verschillende kleuren, die gebruikt worden om alle cellen in te kleuren. Hierbij wordt de toestand van de cell gebruikt als index voor de \markdownRendererCodeSpan{surflist}, dus een cell met toestand in wordt ingekleurd met de surface op plek 0 van de lijst, enzovoort. Zorg ervoor dat deze surfaces vierkant zijn met dezelfde cellgroote als de \markdownRendererCodeSpan{draw} functie.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/63a4c8ef511e582cc98ac8f773e8a491.verbatim}{python}\markdownRendererInterblockSeparator
{}Daarnaast bestaan er een functie die het updaten en weergeven automatisch doen, \markdownRendererCodeSpan{runvisual}. Deze functie neemt als argumenten de breedte en hoogte van het scherm (in pixels), de \markdownRendererCodeSpan{changetime} (tijd tussen updates in millisecondes, vooral nuttig bij CA's die anders te snel gaan), de cellsize in pixels, en een lijst met kleuren voor elke toestand. Als deze lijst kleiner is dan het aantal toestanden, krijgen cellen met een toestand waarvoor geen kleur in de lijst zit de laatste kleur uit de lijst.\markdownRendererInterblockSeparator
{}De visualisatie kan op pauze gezet worden door op de spatiebalk te drukken.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/f05e009390cd19a65cce44970a8b6b3d.verbatim}{python}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Het maken van regels}\markdownRendererInterblockSeparator
{}Voor het maken van regels kan gebruik gemaakt worden van ingebouwde functies die de staten van buurtcellen ophalen. Deze zitten in de \markdownRendererCodeSpan{Neighborhoods}-klasse. Er zijn functies voor 1- en 2-dimensionale buurten, en functies voor buurten met willekeurige dimensie. Voor 1- en 2D wordt aangeraden om de daarvoor bestemde functies te gebruiken en niet de algemene, aangezien die meestal iets langzamer is doordat er gebruik gemaakt wordt van recursie. Er bestaan voor elk van die categorieën nog twee soorten functies, waar het verschil zit in de randvoorwaarden.\markdownRendererInterblockSeparator
{}De standaard \markdownRendererCodeSpan{Neighborhoods.get\markdownRendererUnderscore{}neighbors} functie neemt naast parameters voor het grid, de index van de huidige cell en de reach ook nog een waarde genaamd \markdownRendererCodeSpan{default} aan, die gebruikt wordt wanneer een cell buiten het grid ligt (en dus eigenlijk niet bestaat).\markdownRendererInterblockSeparator
{}De \markdownRendererCodeSpan{Neighborhoods.get\markdownRendererUnderscore{}neighbors\markdownRendererUnderscore{}periodiek} gaat verder vanaf de andere kant wanneer cellen niet bestaan.\markdownRendererInterblockSeparator
{}Deze functies geven als output een lijst met de staten van de cellen. De volgorde begint bij de laagste indexen in alle dimensies, beweegt naar de hoogste index in de hoogste dimensie, en beweegt dan 1 omhoog in de één-na-hoogste dimensie en gaat weer naar de hoogste index in de hoogste dimensie, en dit gaat zo door totdat alle cellen zijn opgehaald.\markdownRendererInterblockSeparator
{}Als voorbeeld maken we hier een functie voor rule 22, één van de elementaire CA's.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/3f402295b6e048604dff520acf3e421e.verbatim}{python}\markdownRendererInterblockSeparator
{}Ook kunnen we hiermee vrij eenvoudig een regelfunctie maken voor Game of Life.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/20b6e92621b6324d19662fd985910a43.verbatim}{python}\markdownRendererInterblockSeparator
{}Ook kunnen we gebruik maken van meerdere toestanden, wat te zien is in het volgende voorbeeld waarbij zieke cellen zijn toegevoegd aan Game of Life, die andere cellen ziek kunnen maken.\markdownRendererInterblockSeparator
{}\markdownRendererInputFencedCode{./_markdown_verslag/4f2cba4b685f81882e100f31375fa55a.verbatim}{python}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Overzicht van functies}\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.CellularAutomata(shape: list, rules)}: Maakt een cellulaire automata aan met de shape voor de vorm van het grid, en een functie rules met als input een cell, een index en het grid en als output de geupdate staat van de cell.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular1D(size: int, rules)}: Maak een 1-dimensionale CA met grootte size en een functie rules met als input een cell, een index en het grid en als output de geupdate staat van de cell.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular2D(width: int, height: int, rules)}: Maak een 2-dimensionale CA met width cellen in de breedte en height cellen in de hoogte en een functie rules met als input een cell, een index en het grid en als output de geupdate staat van de cell.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.CellularAutomata.update()}: Update het hele grid door voor elke cel de rules functie op te roepen om te bepalen wat zijn nieuwe staat moet zijn.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.CellularAutomata.run(updates: int)}: Update het grid een gegeven aantal keer.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.CellularAutomata.setcells(coordinates: list, value: int)}: Verandert de waarden van cellen met de gegeven coördinaten naar de gegeven waarde.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.CellularAutomata.setzeros()}: Verandert alle toestanden in het grid naar 0.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.CellularAutomata.random(max: int)}: Verandert alle toestanden in het grid naar random getallen tussen 0 en max.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular1D.start\markdownRendererUnderscore{}middle()}: Maakt de toestand van de middelste cel gelijk aan 1. Vooral bedoelt voor de elementaire CA's.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular1D.draw(screen: pygame.Surface, cellsize: int, surflist: list)}: Tekent het grid op een screen, scrollt automatisch mee als onderkant van scherm wordt bereikt. Gebruikt de surflist met surfaces om de cellen in te tekenen op basis van de toestand.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular1D.runvisual(width: int, height: int, changetime: int, cellsize: int, colorlist: list)}: Start pygame visualisatie met bepaalde width en height in pixels, changetime geeft tijd in ms tussen updates en colorlist zorgt voor de kleuren per toestand (als lijst met RGB-waardes).\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular2D.draw(screen: pygame.Surface, cellsize: int, surflist: list)}: Tekent het grid op een screen. Gebruikt de surflist met surfaces om de cellen in te tekenen op basis van de toestand.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Cellular2D.runvisual(width: int, height: int, changetime: int, cellsize: int, colorlist: list)}: Start pygame visualisatie met bepaalde width en height in pixels, changetime geeft tijd in ms tussen updates en colorlist zorgt voor de kleuren per toestand (als lijst met RGB-waardes).\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.GameOfLife(width: int, height: int)}: Maakt een 2D CA aan met Game of Life regels.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.GameOfLife.glider(offset\markdownRendererUnderscore{}width: int, offset\markdownRendererUnderscore{}height: int, direction: int)}: Zet een zogenaamde glider in het grid, met de offset ten opzichte van linksboven en de richting een getal tussen 0 en 3, met 0 voor naar linksboven, 1 voor naar rechtsboven, 2 voor linksonder en 3 voor rechtsonder.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Neighborhoods.get\markdownRendererUnderscore{}neighbors\markdownRendererUnderscore{}1D(grid: np.ndarray, idx: list, reach: int, default: int)}: geeft een list met de toestanden van buurtcellen in een 1D Moore-Neighborhood met reach voor de grootte van de buurt. Gebruikt default als cellen niet bestaan.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Neighborhoods.get\markdownRendererUnderscore{}neighbors\markdownRendererUnderscore{}1D\markdownRendererUnderscore{}periodiek(grid: np.ndarray, idx: list, reach: int)}: geeft een list met de toestanden van buurtcellen in een 1D Moore-Neighborhood met reach voor de grootte van de buurt. Gaat verder vanaf de andere kant als cellen niet bestaan.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Neighborhoods.get\markdownRendererUnderscore{}neighbors\markdownRendererUnderscore{}2D(grid: np.ndarray, idx: list, reach: int, default: int)}: geeft een list met de toestanden van buurtcellen in een 2D Moore-Neighborhood met reach voor de grootte van de buurt. Gebruikt default als cellen niet bestaan.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Neighborhoods.get\markdownRendererUnderscore{}neighbors\markdownRendererUnderscore{}2D\markdownRendererUnderscore{}periodiek(grid: np.ndarray, idx: list, reach: int)}: geeft een list met de toestanden van buurtcellen in een 2D Moore-Neighborhood met reach voor de grootte van de buurt. Gaat verder vanaf de andere kant als cellen niet bestaan.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Neighborhoods.get\markdownRendererUnderscore{}neighbors(grid: np.ndarray, idx: list, reach: int, default: int)}: geeft een list met de toestanden van buurtcellen in een willekeurig-dimensionale Moore-Neighborhood met reach voor de grootte van de buurt. Gebruikt default als cellen niet bestaan.\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{CA.Neighborhoods.get\markdownRendererUnderscore{}neighbors\markdownRendererUnderscore{}periodiek(grid: np.ndarray, idx: list, reach: int, default: int)}: geeft een list met de toestanden van buurtcellen in een willekeurig-dimensionale Moore-Neighborhood met reach voor de grootte van de buurt. Gaat verder vanaf de andere kant als cellen niet bestaan.\markdownRendererDocumentEnd